// lus_fact : Type
// Plus_fact = 2+2=4

Plus_fact : Type
Plus_fact = Equal (Plus 2n 2n) 4n

// λΠ> :t Plus_fact
// Plus_fact : Type

// lus_fact_is_true : Plus_fact
// plus_fact_is_true = Re
Plus_fact_is_true : Plus_fact 
Plus_fact_is_true = Equal.refl

// is_three : Nat -> Type
// is_three n = n=3
// Is_three (n: Nat) : Nat -> Type
// Is_three n = Equal.refl n 3n

// Injective : (f : a -> b) -> Type

// Injective <a> <b> (f: a -> b) : Type
// Injective {a} {b} f = (x, y : a) -> f x = f y -> x = y
// Injective a b f = (x: a) => (y: a) => (e: Equal (f x) (f y)) => (Equal x y)

// Succ_inj : Injective S
// Succ_inj <a>: Algebra.Laws.injectivity (x => Nat.succ x)
// Succ_inj = x => ?
// succ_inj : Injective S
// Succ_inj = Equal!j

Algebra.Laws.injectivity <a: Type> <b: Type> (f: a -> b) : Type
Algebra.Laws.injectivity a b f = (x: a) -> (y: a) -> (hyp: Equal b (f x) (f y)) -> (Equal a x y)

Nat.succ_injective : Algebra.Laws.injectivity ((n: Nat) => Nat.succ n)
Nat.succ_injective =
  (a: Nat) =>
  (b: Nat) =>
  (hyp: Equal Nat (Nat.succ a) (Nat.succ b)) =>
  Equal.apply (x => Nat.pred x) hyp

type Injective <a: Type> <b: Type> (f: a -> b) {
  new (p: Algebra.Laws.injectivity f)
}

InjectiveNat : Injective (n => Nat.succ n)
InjectiveNat = Injective.new Nat.succ_injective


ConjuntiveBool : Equal Bool (Bool.and Bool.true Bool.false) Bool.false
ConjuntiveBool = Equal.refl

// and_example : (3 + 4 = 7, 2 * 2 = 4)
// and_example = (Refl, Refl)

And_example : Pair (Equal (Nat.add 3n 4n) 7n) (Equal (Nat.mul 2n 2n) 4n)
And_example = Pair.new Equal.refl Equal.refl

// and_example2 : (n, m : Nat) -> (n = 0, m = 0) -> n + m = 0
// and_example2 Z Z (Refl,Refl) = Refl
// and_example2 (S _) _ (Refl,_) impossible
// and_example2 _ (S _) (_,Refl) impossible

And_example2 (n: Nat) (m: Nat) (e: Pair (Equal n 0n) (Equal m 0n)) : Equal (Nat.add n m) 0n
And_example2 Nat.zero Nat.zero e      = Equal.refl
And_example2 Nat.zero (Nat.succ m) e  =
  let p = (Equal.rewrite
  (Pair.snd e)
  (x => match Nat x {
    zero => Empty
    succ => Unit 
   })
   (Unit.new))
   Empty.absurd p
And_example2 (Nat.succ n) m e = 
  let p = (Equal.rewrite 
     (Pair.fst e)
     (x => match Nat x {
      zero => Empty 
      succ => Unit
      })
      (Unit.new))
  Empty.absurd p



And_example2a (n: Nat) (m: Nat) (e1: Equal n 0n) (e2: Equal m 0n) : Equal (Nat.add n m) 0n
And_example2a Nat.zero Nat.zero e1 e2      = Equal.refl
And_example2a Nat.zero (Nat.succ m) e1 e2  =
  let p = (Equal.rewrite
  (e2)
  (x => match Nat x {
    zero => Empty
    succ => Unit 
   })
   (Unit.new))
   Empty.absurd p
And_example2a (Nat.succ n) m e1 e2  = 
  let p = (Equal.rewrite 
     (e1)
     (x => match Nat x {
      zero => Empty 
      succ => Unit
      })
      (Unit.new))
  Empty.absurd p

And_example3 (n: Nat) (m: Nat) (e: Equal (Nat.add n m) 0n) : Equal (Nat.mul n m) 0n
And_example3 Nat.zero m e =  Equal.refl
And_example3 (Nat.succ n) m e =
  let p = (Equal.rewrite 
     (e)
     (x => match Nat x {
      zero => Empty 
      succ => Unit
      })
      (Unit.new))
  Empty.absurd p


// proj1 : (p, q) -> p
// proj1 = fst

Proj1 <p> <q> (a: Pair p q) : p
Proj1 (Pair.new fst snd)    = fst


// proj2 : (p, q) -> q
// proj2 x = ?proj2_rh

Proj2 <p> <q> (b: Pair p q) : q
Proj2 (Pair.new fst snd)    = snd

// and_commut : (p, q) -> (q, p)
// and_commut (p, q) = (q, p)
And_commut <p> <q> (c: Pair p q) : Pair q p
And_commut (Pair.new fst snd)    = Pair.new snd fst

// and_assoc : (p, (q, r)) -> ((p, q), r)
// and_assoc x = ?and_assoc_rh
And_assoc <p> <q> <r> (a: Pair p (Pair q r))  : Pair (Pair p q) r
And_assoc (Pair.new p (Pair q r) fst (Pair.new snd trd)) = Pair.new (Pair.new fst snd) trd

Or_example (n: Nat) (m: Nat) (e: (Either (Equal n 0n) (Equal m 0n))) : Equal (Nat.mul n m) 0n
Or_example Nat.zero m e     = Equal.refl
Or_example n Nat.zero e     = Mult_0_r n
Or_example (Nat.succ n) m (Either.left l r val) = 
  let p = (Equal.rewrite
    (val)
    (x => match Nat x {
      zero => Empty 
      succ => Unit
      })
    (Unit.new))
  Empty.absurd p
Or_example (Nat.succ n) (Nat.succ m) (Either.right l r val) = 
  let p = (Equal.rewrite 
  (val)
  ( x => match Nat x {
    zero => Empty
    succ => Unit 
    })
    Unit.new)
  Empty.absurd p

// or_intro : a -> a `Either` b
// or_intro = Left

#axiom
Or_intro <a> <b> (c:  Either a b)       : a
Or_intro a b (Either.left  lft rgt val) = val
// Or_intro a b (Either.right lft rgt val) =
  // ?

// zero_or_succ : (n : Nat) -> ((n = 0) `Either` (n = S (pred n)))
// zero_or_succ Z      = Left Refl
// zero_or_succ (S n)  = Right Refl

Pred (n: Nat) : Nat
Pred Nat.zero     = Nat.zero
Pred (Nat.succ m) = m

Zero_or_succ (n: Nat) : Either (Equal n Nat.zero) (Equal n (Nat.succ (Pred n)))
Zero_or_succ Nat.zero     = Either.left Equal.refl
Zero_or_succ (Nat.succ m) = Either.right Equal.refl 

// mult_eq_0 : n * m = 0 -> ((n = 0) `Either` (m = 0))
// mult_eq_0 prf = ?
#axiom
Mult_eq_0 (n: Nat) (m: Nat) (e: Equal (Nat.mul n m) 0n) : Either (Equal n 0n) (Equal m 0n)
Mult_eq_0 Nat.zero m e = Either.left Equal.refl
Mult_eq_0 n Nat.zero e = Either.right Equal.refl
// Mult_eq_0 (Nat.succ n) (Nat.succ m) e = ?

// or_commut : (p `Either` q) -> (q `Either` p)
// or_commut x = ?p

Or_commut <q> <p> (e: Either p q) : Either q p
Or_commut q p (Either.left  lft rgt val) = Either.right rgt lft val
Or_commut q p (Either.right lft rgt val) = Either.left  rgt lft val



// ex_falso_quodlibet : Void -> p
// ex_falso_quodlibet = void

Ex_falso_quodlibet <p> : Empty -> p
Ex_falso_quodlibet p = e => Empty.absurd e

// Como tá no livro
// not_implies_our_not : Not p -> (q -> (p -> q))
// not_implies_our_not notp q p = ?not_implies_our_not_rhs

// Se `(q -> (p -> q)) = Empty` 
Not_implies_our_not1 <p> (e: Not p) : p -> Empty
Not_implies_our_not1 p e = e

// Se recebe apenas UM parêmetro 
Not_implies_our_not2 <p> <q> (e: Not p) : q -> (p -> q)
Not_implies_our_not2 p q e = (x: q) => (y: p) => x

// Se tudo for parâmetro e tetorna só o `q` do final
Not_implies_our_not3 <p> <q> (notp: Not p) (que: q) (pe: p) : q
Not_implies_our_not3 p q notp que pe = que

// zero_not_one : Not (Z = S _)
// zero_not_one = \Refl impossible
Zero_not_one : Not (Equal Nat.zero (Nat.succ Nat.zero))
Zero_not_one = 
  (emp => 
    let app = Equal.apply (x => Nat.is_zero x) emp
    Equal.rewrite app (e => if e {Nat} else {Empty}) Nat.zero)

// not_False : Not Void
// not_False = absurd
Not_false : Not Empty
Not_false = e => Empty.absurd e

// contradiction_implies_anything : (p, Not p) -> q
// contradiction_implies_anything (p, notp) = absurd $ notp p
Contradiction_implies_anythig <p> <q> (a: Pair p (Not p)) : q
Contradiction_implies_anythig p q (Pair.new fst snd) =
  let app = snd fst
  Empty.absurd app

// double_neg : p -> Not $ Not p
// double_neg p notp = notp p
Double_neg <p>  : Not (Not p) 
Double_neg p    = 
  // let test = (x: p -> Empty) => (y: Empty) => y
  let nas   = (x: p) => (y: Empty) => y
  let test  = (x: p -> Empty) => Empty.absurd nas
  ?
  // test
  // nas

// expected : ((x_1 : ((x_1 : p) -> Empty)) -> Empty)
// test     : ((x_3 : p) -> (x_1 : ((x_2 : x) -> Empty)) -> (x_2 : x) -> Empty)

Main {
     Nat.show (Inc 0n)
}

Mult_0_r (n: Nat)     : (Equal Nat (Nat.mul n Nat.zero) Nat.zero)
Mult_0_r Nat.zero     = Equal.refl
Mult_0_r (Nat.succ n) = 
  let ind = Mult_0_r n
  let app = Equal.apply (x => (Nat.add x Nat.zero)) ind
  app


Mult_n_m_eq_z (n: Nat) (m: Nat) (e: Equal m 0n)   : (Equal _ (Nat.add (Nat.mul n m) m) 0n)
Mult_n_m_eq_z Nat.zero m e = e
Mult_n_m_eq_z (Nat.succ n) m e = 
  let ind = Mult_n_m_eq_z n m e
  let app = Equal.apply (x => Nat.add x m) ind
  let rwt = Equal.rewrite e (x => (Equal Nat (Nat.add (Nat.add (Nat.mul n m) m) m) x)) app
  rwt

Inc (n: Nat)  : Nat
Inc n         = ((x: Nat) => Nat.succ x) n

Pair_second<a> <b> (e: Pair a b) : b
Pair_second (Pair.new a b) = b

Plus_comm (n: Nat) (m: Nat) : (Equal Nat (Nat.add n m) (Nat.add m n))
Plus_comm Nat.zero m        = Plus_n_z m
Plus_comm (Nat.succ n) m    = (Equal.chain (Equal.apply (x => (Nat.succ x))(Plus_comm n m)) (Plus_n_sn m n))

Plus_n_z (n: Nat)     : (Equal Nat n (Nat.add n Nat.zero))
Plus_n_z Nat.zero     = Equal.refl
Plus_n_z (Nat.succ n) = (Equal.apply (x => (Nat.succ x)) (Plus_n_z n))

Plus_n_sn (n: Nat) (m: Nat) : (Equal Nat (Nat.succ (Nat.add n m))(Nat.add n (Nat.succ m)))
Plus_n_sn Nat.zero m        = Equal.refl
Plus_n_sn (Nat.succ n) m    = (Equal.apply (x => (Nat.succ x)) (Plus_n_sn n m))

#axiom
Either.rgt <l> <r> (e: Either l r) : r

#axiom
Either.lft <l> <r> (e: Either l r) : l



Plus_comm_add (n: Nat)       : (Equal Nat (Nat.add n n) (Nat.double n))
Plus_comm_add Nat.zero       = Equal.refl
Plus_comm_add (Nat.succ n)   =
    let ind0 = Plus_comm_add n
    let ind1 = Equal.mirror (Equal.apply (x => (Nat.succ x)) ind0)
    let ind2 = Plus_comm_aux n n
    let chn  = Equal.chain ind1 ind2
    let app  = Equal.apply (x => (Nat.succ x)) (Equal.mirror chn)
    app

Plus_comm_aux (n: Nat) (m: Nat)         : (Equal Nat  (Nat.succ (Nat.add n m)) (Nat.add n (Nat.succ m)))
Plus_comm_aux Nat.zero m                = Equal.refl
Plus_comm_aux (Nat.succ n) m            =
    let ind = Plus_comm_aux n m
    let app = Equal.apply (x => (Nat.succ x)) ind
    app


App_nil_r <t> (xs: List t)              : (Equal (List.concat xs List.nil) xs)
App_nil_r List.nil                    = Equal.refl
App_nil_r (List.cons xs.head xs.tail) =
  let ind = App_nil_r xs.tail
  let app = Equal.apply (x => (List.cons xs.head x)) ind
  app


App_length <a> (xs: List a) (ys: List a)  : (Equal Nat (List.length (List.concat xs ys)) (Nat.add (List.length xs) (List.length ys)))
App_length List.nil ys                    = Equal.refl
App_length (List.cons xs.head xs.tail) ys =
  let ind = App_length xs.tail ys
  let app = Equal.apply (x => (Nat.succ x)) ind
  app


// Combine_odd_even_intro Nat.zero podd peven p1 p2                = p2 Equal.refl
// Combine_odd_even_intro (Nat.succ Nat.zero) podd peven p1 p2     = p1 Equal.refl
// Combine_odd_even_intro (Nat.succ n) podd peven p1 p2     =
  // let is_odd  = (x: Equal (Nat.is_odd (Nat.succ n)) Bool.true)  => p1 x
  // let is_even = (x: Equal (Nat.is_odd (Nat.succ n)) Bool.false) => p2 x
  // let bool_if = Bool.if (Nat.is_odd (Nat.succ n)) is_odd is_even

Add_z_r (n: Nat)       : (Equal (Nat.add n Nat.zero) n)
Add_z_r Nat.zero       = Equal.refl
Add_z_r (Nat.succ n)   =
     let ind = Add_z_r n
     let app = (Equal.apply (x => (Nat.succ x)) ind)
     app

Confia <x> (e : x -> Type) : Type
// Confia <x> : Type
// Confia x e =

Rev <a> (xs: List a)      : List a
Rev List.nil              = List.nil 
Rev (List.cons head tail) = List.concat (Rev tail) [head]

Nat.show (n: Nat) : String {
  (Nat.to_string_base (U60.to_nat 10) n )
}

Plus (n: Nat) (m: Nat)  : Nat
Plus Nat.zero m         = m
Plus (Nat.succ n) m     = Nat.succ (Plus n m)

Example_apply (n: Nat) (m: Nat) (e: Equal m n) : Equal (Nat.succ m) (Nat.succ n)
Example_apply n m e = 
  let e_apply = Equal.apply (x => Nat.succ x) e
  e_apply

Example_case_analysis (b1: Bool)  : Equal (Bool.and b1 Bool.false) Bool.false
Example_case_analysis Bool.true   = Equal.refl
Example_case_analysis Bool.false  = Equal.refl

Plus_id_example (n: Nat) (m: Nat) (e: Equal n m) : Equal (Plus n n) (Plus m m)
Plus_id_example n m e = 
  let app = Equal.apply (x => Plus x n) e
  Equal.rewrite e (x => Equal (Plus n n) (Plus m x)) app 

Problems.t0 (n: Nat) : Equal Nat (Nat.add Nat.zero n) n
Problems.t0 n = Equal.refl

Problems.t1 (n: Nat)      : (Equal Nat (Nat.add n Nat.zero) n)
Problems.t1 Nat.zero      = Equal.refl
Problems.t1 (Nat.succ n)  = 
  let ind = Problems.t1 n  
  let app = Equal.apply (x => (Nat.succ x)) ind
  app

Problems.t2 (n: Nat) (m: Nat) : Equal Nat (Nat.add n (Nat.succ m)) (Nat.succ (Nat.add n m))
Problems.t2 Nat.zero m        = Equal.refl
Problems.t2 (Nat.succ n) m    = 
  let ind = Problems.t2 n m
  let app = Equal.apply (x => (Nat.succ x)) ind
  app

Problems.t3 (n: Nat) (m: Nat) : Equal Nat (Nat.add n m ) (Nat.add m n)
Problems.t3 Nat.zero Nat.zero       = Equal.refl
Problems.t3 Nat.zero (Nat.succ m)   =
  let ind = Problems.t1 m
  let app = Equal.apply (x => Nat.succ x) ind
  Equal.mirror app
Problems.t3 (Nat.succ n) m          = 
  let ind_a = Equal.apply (x => (Nat.succ x)) (Problems.t3 n m)
  let ind_b = Problems.t2 m n
  let ind_c = Equal.chain ind_b (Equal.mirror ind_a)
  let app   = Equal.mirror ind_c
  app


  // (Equal Nat (Nat.succ m) (Nat.succ (Nat.add m 0n)))

Doit3times <x> (f: x -> x) (n: x) : x
Doit3times f n = (f (f ( f n )))

Test_anon_fun : Equal (Doit3times (x => (Nat.mul x x)) (U60.to_nat 2)) (U60.to_nat 256)
Test_anon_fun = Equal.refl

Filter <x> (test: x -> Bool) (xs: List x) : List x
Filter test List.nil  = List.nil
Filter test (List.cons xs.h xs.t) =
  Bool.if (test xs.h) (List.cons xs.h (Filter test xs.t)) (Filter test xs.t)

Length_is_one <x> (xs: List x)  : Bool
Length_is_one xs                = Nat.equal (List.length xs) (Nat.succ Nat.zero)

Test_filter : Equal (Filter (x => (Length_is_one x))([[1], [1, 2], [2], [1, 2, 3], [21]])) ([[1], [2], [21]])
Test_filter = Equal.refl // teste

Filter_even_gt7 (xs: List Nat) : List Nat
Filter_even_gt7  xs = Filter (x => Nat.gtn x 7n) (Filter (y => Nat.is_even y) xs)


Test_filter_even_gt7: Equal (Filter_even_gt7 [1n, 2n, 3n, 4n, 5n, 6n, 7n, 8n, 9n, 10n, 11n, 12n]) ([8n, 10n, 12n]) 
Test_filter_even_gt7 = Equal.refl

Test_filter_even_gt7a: Equal (Filter_even_gt7 [5n, 2n, 6n, 19n, 129n]) ([]) 
Test_filter_even_gt7a = Equal.refl

Flat_map <x> <y> (f: x -> List y) (xs: List x)  : List y
Flat_map f List.nil                             = List.nil
Flat_map f (List.cons xs.h xs.t)                = List.concat (f xs.h) (Flat_map f xs.t)

Maybe_map <x> <y> (f: x -> y) (a: Maybe x)  : Maybe y
Maybe_map f Maybe.none                      = Maybe.none
Maybe_map f (Maybe.some x)                  = (Maybe.some (f x))

Fold <x> <y> (f: x -> y -> y) (xs: List x) (a: y) : y
Fold f List.nil a                                 = a
Fold f (List.cons xs.h xs.t) a                    = f xs.h (Fold f xs.t a)

Constfun <y> (x: y) : Nat -> y
Constfun x = y => x 

Ftrue : Nat -> Bool
Ftrue = Constfun Bool.true

Constfun_example1 : Equal ((Ftrue) 0n) Bool.true
Constfun_example1 = Equal.refl

Constfun_example2 : Equal ((Constfun 5n) 99n) 5n
Constfun_example2 = Equal.refl

Plus3 (n: Nat) : Nat
Plus3 n = Plus 3n n

Test_plus3_1 : Equal (Plus3 4n) 7n
Test_plus3_1 = Equal.refl

Test_plus3_2 : Equal (Doit3times (x => Plus3 x) 0n) 9n
Test_plus3_2 = Equal.refl

Test_plus3_3 : Equal (Doit3times (x => Plus 3n x) 0n)9n
Test_plus3_3 = Equal.refl

Fold_length <x> (xs : List x) : Nat
Fold_length xs = Fold  (x => y => Nat.succ y) xs 0n

Test_fold_length1 : Equal (Fold_length [4, 7, 0]) 3n
Test_fold_length1 = Equal.refl

Fold_length_correct <x> (xs: List x): Equal (Fold_length xs) (List.length xs)
Fold_length_correct List.nil = Equal.refl
Fold_length_correct (List.cons xs.h xs.t) = 
  let ind = Fold_length_correct xs.t
  let app = Equal.apply (x => Nat.succ x) ind
  app

Fold_map <a> <b> (f: a -> b) (xs: List a) : List b
Fold_map f List.nil               = List.nil
Fold_map f (List.cons xs.h xs.t)  = List.cons (Fold (x => y => f x) (List.cons xs.h xs.t) (f xs.h)) (Fold_map f xs.t )

Test_fm1 : Equal (Fold_map (x => Nat.add x 3n) [1n, 2n, 3n]) ([4n, 5n, 6n])
Test_fm1 = Equal.refl

Test_fm2 <x> <y> (f: x -> y) (xs: List x) : Equal (Fold_map f xs) (List.map xs f)
Test_fm2 f List.nil               = Equal.refl
Test_fm2 f (List.cons xs.h xs.t)  =
  let ind = Test_fm2 f xs.t
  let app = Equal.apply ( x => (List.cons (f xs.h) x)) ind
  app

Pair_curry <x> <y> <z> (f: (Pair x y) -> z) (x.val: x) (y.val: y) : z
Pair_curry f  x.val y.val = f (Pair.new x.val y.val)

Pair_uncurry <x> <y> <z> (f: x -> y -> z) (p: Pair x y) :  z
Pair_uncurry f (Pair.new x.val y.val)                   = f x.val y.val

Test_map2_1 : Equal (Fold_map (x => Plus 3n x) [2n, 0n, 2n]) [5n, 3n, 5n]
Test_map2_1 = Equal.refl

Uncurry_curry <x> <y> <z> (f: x -> y -> z) (x.val: x) (y.val: y) : Equal (Pair_curry (p => Pair_uncurry f p) x.val y.val) (f x.val y.val)
Uncurry_curry f x y = Equal.refl

Num <x> : Type
Num x   = (x -> x) -> x -> x

One     : Num
One     = s => z => s z

Zero    : Num
Zero    = s => z => z

Two     : Num
Two     = s => z => s (s z)

Three   : Num
Three   = s => z => Doit3times s z

Succ (n: Num) : (Num)
Succ  n       = s => z => s (n s z)

Succ_1  : Equal (Succ Zero) (One)
Succ_1  = Equal.refl

Succ_2  : Equal (Succ One) (Two)
Succ_2  = Equal.refl

Succ_3  : Equal (Succ Two) Three
Succ_3  = Equal.refl


// plus' : (n, m : Nat' {x}) -> Nat' {x}
// plus' n m = ?plus__rhs

// C3+4 = λf . λx . C3 f (C4 f x

Plus_church (n: Num) (m: Num) : Num
Plus_church n m = (s: Num) => (z: Num) => m s (n s z)

Plus_c_1 : Equal (Plus_church Zero One) (One)
Plus_c_1 = Equal.refl

Plus_c_2 : Equal (Plus_church Two Three) (Plus_church Three Two)
Plus_c_2 = Equal.refl

Plus_c_3 : Equal (Plus_church (Plus_church Two Two) Three) (Plus_church One (Plus_church Three Three))
Plus_c_3 = Equal.refl


Mult (n: Num) (m: Num) : Num
Mult n m = (s: Num) => (z: Num) => n (m s) z

Mult_1 : Equal (Mult One One) One
Mult_1 = Equal.refl

Mult_2 : Equal (Mult Zero (Plus_church Three Three)) Zero
Mult_2 = Equal.refl

Mult_3 : Equal (Mult Two Three) (Plus_church Three Three)
Mult_3 = Equal.refl


Exp (n: Num) (m: Num -> Num) : Num 
Exp n m = (s: Num) => (z: Num) => m n s z

Exp1 : Equal (Plus_church (Exp Two Two) One) (Plus_church Two Three)
Exp1 = Equal.refl

Exp2 : Equal (Exp Three Two) (Plus_church (Mult Two (Mult Two Two)) One)
Exp2 = Equal.refl

Exp3 : Equal (Exp Three Zero) One
Exp3 = Equal.refl

Exp4 : Equal (Exp Two Two) (Plus_church Two Two)
Exp4 = Equal.refl


// Pred.aux (n: Num) (m: Num) : Num
// Pred.aux n m = m n

// Pred (n: Num) : Num
// Pred n = Pred.aux n One

// (f => (m => (f (f (f (f (f (f (f (f m))))))))))

// λn λf λx (((n λg λh (h (g f)))λu x) λu u)
// Dec (n: Num)  : Num
// Dec n =
// Dec n = f => x => (n (g => h => h (g f)) (u => x)) (u => u)
// -----------------------------------------------------------
// n => f => x => ((n (g => (u => x) (g f))) (u => u))
// -----------------------------------------------------------
// n => f => x => ((n (g => (u => x) ((u => u) f))))
// -----------------------------------------------------------
// n => f => ((n ((u => u => u) ( f))))
// -----------------------------------------------------------
// n => f => x => ((n (g => h => h (g f)) (u => x)) (u => u))
// -----------------------------------------------------------
//

// Pred1 : Equal (Pred Three) Two
// Pred1 = ?


// CAP 6
// lus_fact : Type
// Plus_fact = 2+2=4

Plus_fact : Type
Plus_fact = Equal (Plus 2n 2n) 4n

// λΠ> :t Plus_fact
// Plus_fact : Type

// lus_fact_is_true : Plus_fact
// plus_fact_is_true = Re
Plus_fact_is_true : Plus_fact 
Plus_fact_is_true = Equal.refl

// is_three : Nat -> Type
// is_three n = n=3
// Is_three (n: Nat) : Nat -> Type
// Is_three n = Equal.refl n 3n

// Injective : (f : a -> b) -> Type

// Injective <a> <b> (f: a -> b) : Type
// Injective {a} {b} f = (x, y : a) -> f x = f y -> x = y
// Injective a b f = (x: a) => (y: a) => (e: Equal (f x) (f y)) => (Equal x y)

// Succ_inj : Injective S
// Succ_inj <a>: Algebra.Laws.injectivity (x => Nat.succ x)
// Succ_inj = x => ?
// succ_inj : Injective S
// Succ_inj = Equal!j

Algebra.Laws.injectivity <a: Type> <b: Type> (f: a -> b) : Type
Algebra.Laws.injectivity a b f = (x: a) -> (y: a) -> (hyp: Equal b (f x) (f y)) -> (Equal a x y)

Nat.succ_injective : Algebra.Laws.injectivity ((n: Nat) => Nat.succ n)
Nat.succ_injective =
  (a: Nat) =>
  (b: Nat) =>
  (hyp: Equal Nat (Nat.succ a) (Nat.succ b)) =>
  Equal.apply (x => Nat.pred x) hyp

type Injective <a: Type> <b: Type> (f: a -> b) {
  new (p: Algebra.Laws.injectivity f)
}

InjectiveNat : Injective (n => Nat.succ n)
InjectiveNat = Injective.new Nat.succ_injective

ConjuntiveBool : Equal Bool (Bool.and Bool.true Bool.false) Bool.false
ConjuntiveBool = Equal.refl

And_example : Pair (Equal (Nat.add 3n 4n) 7n) (Equal (Nat.mul 2n 2n) 4n)
And_example = Pair.new Equal.refl Equal.refl

And_example2 (n: Nat) (m: Nat) (e: Pair (Equal n 0n) (Equal m 0n)) : Equal (Nat.add n m) 0n
And_example2 Nat.zero Nat.zero e      = Equal.refl
And_example2 Nat.zero (Nat.succ m) e  =
  let p = (Equal.rewrite
  (Pair.snd e)
  (x => match Nat x {
    zero => Empty
    succ => Unit 
   })
   (Unit.new))
   Empty.absurd p
And_example2 (Nat.succ n) m e = 
  let p = (Equal.rewrite 
     (Pair.fst e)
     (x => match Nat x {
      zero => Empty 
      succ => Unit
      })
      (Unit.new))
  Empty.absurd p

And_example2a (n: Nat) (m: Nat) (e1: Equal n 0n) (e2: Equal m 0n) : Equal (Nat.add n m) 0n
And_example2a Nat.zero Nat.zero e1 e2      = Equal.refl
And_example2a Nat.zero (Nat.succ m) e1 e2  =
  let p = (Equal.rewrite
  (e2)
  (x => match Nat x {
    zero => Empty
    succ => Unit 
   })
   (Unit.new))
   Empty.absurd p
And_example2a (Nat.succ n) m e1 e2  = 
  let p = (Equal.rewrite 
     (e1)
     (x => match Nat x {
      zero => Empty 
      succ => Unit
      })
      (Unit.new))
  Empty.absurd p

And_example3 (n: Nat) (m: Nat) (e: Equal (Nat.add n m) 0n) : Equal (Nat.mul n m) 0n
And_example3 Nat.zero m e =  Equal.refl
And_example3 (Nat.succ n) m e =
  let p = (Equal.rewrite 
     (e)
     (x => match Nat x {
      zero => Empty 
      succ => Unit
      })
      (Unit.new))
  Empty.absurd p

Proj1 <p> <q> (a: Pair p q) : p
Proj1 (Pair.new fst snd)    = fst

Proj1a <p> <q>  : (Pair p q) -> p
Proj1a p q      = (x: (Pair p q)) => Pair.fst x

Proj2 <p> <q> (b: Pair p q) : q
Proj2 (Pair.new fst snd)    = snd

Proj2a <p> <q>  : (Pair p q) -> q
Proj2a p q      = (x: (Pair p q)) => Pair.snd x

And_commut <p> <q> (c: Pair p q) : Pair q p
And_commut (Pair.new fst snd)    = Pair.new snd fst

And_assoc <p> <q> <r> (a: Pair p (Pair q r))              : Pair (Pair p q) r
And_assoc (Pair.new p (Pair q r) fst (Pair.new snd trd))  = Pair.new (Pair.new fst snd) trd

Or_example (n: Nat) (m: Nat) (e: (Either (Equal n 0n) (Equal m 0n))) : Equal (Nat.mul n m) 0n
Or_example Nat.zero m e     = Equal.refl
Or_example n Nat.zero e     = Mult_0_r n
Or_example (Nat.succ n) m (Either.left l r val) = 
  let p = (Equal.rewrite
    (val)
    (x => match Nat x {
      zero => Empty 
      succ => Unit
      })
    (Unit.new))
  Empty.absurd p
Or_example (Nat.succ n) (Nat.succ m) (Either.right l r val) = 
  let p = (Equal.rewrite 
  (val)
  ( x => match Nat x {
    zero => Empty
    succ => Unit 
    })
    Unit.new)
  Empty.absurd p

#axiom
Or_intro <a> <b> (t: a) : Either a b
Or_intro t              = Either.left t

Pred (n: Nat)     : Nat
Pred Nat.zero     = Nat.zero
Pred (Nat.succ m) = m

Zero_or_succ (n: Nat)     : Either (Equal n Nat.zero) (Equal n (Nat.succ (Pred n)))
Zero_or_succ Nat.zero     = Either.left  Equal.refl
Zero_or_succ (Nat.succ m) = Either.right Equal.refl 

#axiom
Mult_eq_0 (n: Nat) (m: Nat) (e: Equal (Nat.mul n m) 0n) : Either (Equal n 0n) (Equal m 0n)
Mult_eq_0 Nat.zero m e = Either.left  Equal.refl
Mult_eq_0 n Nat.zero e = Either.right Equal.refl

Or_commut <q> <p> (e: Either p q)         : Either q p
Or_commut q p (Either.left  lft rgt val)  = Either.right rgt lft val
Or_commut q p (Either.right lft rgt val)  = Either.left  rgt lft val

Ex_falso_quodlibet <p>  : Empty -> p
Ex_falso_quodlibet p    = e => Empty.absurd e

// Se `(q -> (p -> q)) = Empty` 
Not_implies_our_not1 <p> (e: Not p) : p -> Empty
Not_implies_our_not1 p e            = e

// Se recebe apenas UM parêmetro 
Not_implies_our_not2 <p> <q> (e: Not p) : q -> (p -> q)
Not_implies_our_not2 p q e              = (x: q) => (y: p) => x

// Se tudo for parâmetro e tetorna só o `q` do final
Not_implies_our_not3 <p> <q> (notp: Not p) (que: q) (pe: p) : q
Not_implies_our_not3 p q notp que pe = que

// zero_not_one = \Refl impossible
Zero_not_one : Not (Equal Nat.zero (Nat.succ Nat.zero))
Zero_not_one = 
  (emp => 
    let app = Equal.apply (x => Nat.is_zero x) emp
    Equal.rewrite app (e => if e {Nat} else {Empty}) Nat.zero)

Not_false : Not Empty
Not_false = e => Empty.absurd e

Contradiction_implies_anythig <p> <q> (a: Pair p (Not p)) : q
Contradiction_implies_anythig p q (Pair.new fst snd) =
  let app = snd fst
  Empty.absurd app

Double_neg <p>  : p -> Not (Not p)
Double_neg p    = (x: p) => (y: Not p) => Contradiction_implies_anythig (Pair.new x y)


Contrapositive <p> <q>  : (p -> q) -> ((Not q) -> (Not p))
Contrapositive p q      = (x: p -> q) => (y: Not q) => (z: p) => y (x (z))

// • Expected: ((x_4 : ((x_5 : p) -> q)) -> (x_6 : ((x_1 : q) -> Empty)) -> (x_1 : p) -> Empty)
// • test    : ((x_2 : ((x_3 : p) -> q)) -> (x_1 : ((x_1 : q) -> Empty)) -> (x_3 : p) -> q)

Not_both_true_and_false <p> : Not (Pair p (Not p))
Not_both_true_and_false p   = (x: (Pair p (Not p))) => Contradiction_implies_anythig x
  // let test1 = (x: (Pair p (Not p))) => (Pair.fst x)
  // let test2 = (x: (Pair p (Not p))) => (Pair.snd x)
  // ?

// • Expected: ((x_1 : (Pair p ((x_1 : p) -> Empty))) -> Empty)

Not_true_is_false (b: Bool) (h: Not (Equal Bool b Bool.true)) : (Equal Bool b Bool.false)
Not_true_is_false Bool.false h = Equal.refl
Not_true_is_false Bool.true  h = Empty.absurd (h Equal.refl)

True_is_true : Unit
True_is_true = Unit.new 

// iff : {p,q : Type} -> Type
// iff {p} {q} = (p -> q, q -> p)

record Equivalence (p) (q) {
  lft: p -> q
  rgt: q -> p
}

// #axiom
Equivalence.rgt <p> <q> (e: Equivalence p q)  : q
Equivalence.rgt (Equivalence.new p q l r)     = l (Equivalence.lft (Equivalence.new p q l r))

// #axiom
Equivalence.lft <p> <q> (e: Equivalence p q)  : p
Equivalence.lft (Equivalence.new p q l r)     = r (Equivalence.rgt (Equivalence.new p q l r))

// iff_sym : (p <-> q) -> (q <-> p)
// iff_sym (pq, qp) = (qp, pq)

Iff_sym <p> <q> (par: Pair (Equivalence p q) (Equivalence q p)) : Pair (Equivalence q p) (Equivalence p q)
Iff_sym p q (Pair.new pq qp) = (Pair.new qp pq)

// not_true_iff_false : (Not (b = True)) <-> (b = False)
// not_true_iff_false {b} = (not_true_is_false b, not_true_and_false b)

Not_true_iff_false (b: Bool) : Equivalence (Not (Equal Bool b Bool.true)) (Equal b Bool.false)
Not_true_iff_false b = Equivalence.new (x => (Not_true_is_false b x)) (y => (Not_true_and_false b y))
//


// not_true_and_false : (b : Bool) -> (b = False) -> Not (b = True)
// not_true_and_false False _ Refl impossible
// not_true_and_false True Refl _ impossible
Not_true_and_false (b: Bool) (h: Equal b Bool.false) : (Not (Equal b Bool.true))
Not_true_and_false (Bool.false) Equal.refl = 
  emp =>
    let p = (Equal.rewrite emp
    (x => match Bool x {
      false => Unit
      true  => Empty
    })
    (Unit.new)) 
  Empty.absurd p
Not_true_and_false Bool.true h = 
    let p = (Equal.rewrite h
    (x => match Bool x {
      false => Empty
      true  => Unit
    })
    (Unit.new)) 
  Empty.absurd p
// ?

// iff_refl : p <-> p
// iff_refl = ?iff_refl_r
Equivalence.refl <p>  : Equivalence p p 
Equivalence.refl p    = (Equivalence.new p p (p => p) (p => p))


// iff_trans : (p <-> q) -> (q <-> r) -> (p <-> r)
// iff_trans piq qir = ?iff_trans_rhs
#partial
Equivalence.chain <p> <q> <r> (e0: Equivalence p q) (e1: Equivalence q r) : Equivalence p r
Equivalence.chain p q r e0 (Equivalence.refl x) = e0 :: Equivalence p x

// or_distributes_over_and : (p `Either` (q,r)) <-> (p `Either` q, p `Either` r)
// or_distributes_over_and = ?or_distributes_over_and_rhs
//  TODO: Resolver
// Or_distributes_over_and <p> <q> <r> : Equivalence (Either p (Pair q r)) (Pair (Either p q) (Either p r))
// Or_distributes_over_and p q r = ?

// mult_0 : (n * m = Z) <౦> ((n = Z) `Either` (m = Z))
// mult_0 {n} {m} = (to n m, or_example n m)
// where
Mult_0 (n: Nat) (m: Nat) : Equivalence (Equal Nat (Nat.mul n m) 0n) (Either (Equal Nat n 0n) (Equal Nat m 0n))
Mult_0 n m = Equivalence.new (x => To_mult_0 n m x) (y => Or_example n m y)

// to : (n, m : Nat) -> (n * m = Z) -> (n = 0) `Either` (m = 0)
// to Z _ Refl = Left Refl
// to (S _) Z _ = Right Refl
// to (S _) (S _) Refl impossible
To_mult_0 (n: Nat) (m: Nat) (e: Equal Nat (Nat.mul n m) 0n) : (Either (Equal Nat n 0n) (Equal Nat m 0n))
To_mult_0 Nat.zero Nat.zero Equal.refl  = Either.left   Equal.refl
To_mult_0 Nat.zero (Nat.succ n) e       = Either.left   Equal.refl
To_mult_0 (Nat.succ n) Nat.zero e       = Either.right  Equal.refl
To_mult_0 (Nat.succ n) (Nat.succ m) e   = 
  let plus_comm = Plus_comm (Nat.mul n (Nat.succ m)) (Nat.succ m)
  let chn_mir   = Equal.chain (Equal.mirror e) plus_comm 
  let absurdo   = 
  (Equal.rewrite chn_mir 
    (x => match Nat x {
      zero => Unit
      succ => Empty
    })
    (Unit.new))
  Empty.absurd absurdo

  // ?

// • Expected   : (Either (Equal Nat (Nat.succ n) 0n) (Equal Nat (Nat.succ m) 0n))
// • e          : (Equal Nat (Nat.add (Nat.mul n (Nat.succ m)) (Nat.succ m)) 0n)
// • plus_comm  : (Equal Nat (Nat.add n m) (Nat.add m n))
// • chn_mir    : (Equal Nat 0n (Nat.succ (Nat.add m (Nat.mul n (Nat.succ m)))))

Or_assoc <p> <q> <r> : Equivalence (Either p (Either q r)) (Either (Either p q) r)
Or_assoc p q r = Equivalence.new (x => To_or_assoc x) (y => Fro_or_assoc y)

To_or_assoc <p> <q> <r> (e: Either p (Either q r))          : Either      (Either p q) r 
To_or_assoc (Either.left e)                                 = Either.left (Either.left e)
To_or_assoc (Either.right p (Either q r) (Either.left e))   = Either.left (Either.right e)
To_or_assoc (Either.right p (Either q r) (Either.right e))  = Either.right e

Fro_or_assoc <p> <q> <r> (e: Either (Either p q) r)         : Either p (Either q r)
Fro_or_assoc (Either.left (Either p q) r (Either.right e))  = Either.right (Either.left e)
Fro_or_assoc (Either.left (Either p q) r (Either.left  e))  = Either.left e
Fro_or_assoc (Either.right e)                               = Either.right (Either.right e)


// mult_0_3 : (n * m * p = Z) <->
// ((n = Z) `Either` ((m = Z) `Either` (p = Z)))
// mult_0_3 = (to, fro)
// where
Mult_0_3 (n: Nat) (m: Nat) (p: Nat) : Equivalence (Equal (Nat.mul n (Nat.mul m p)) Nat.zero) (Either (Equal n Nat.zero) (Either (Equal m Nat.zero) (Equal p Nat.zero)))
Mult_0_3 n m p = Equivalence.new (x => To_mult_0_3 n m p x) (y => Fro_mult_0_3 n m p y) 


// to : (n * m * p = Z) -> ((n = Z) `Either` ((m = Z) `Either` (p = Z)))
// to {n} {m} {p} prf = let
//    (nm_p_to, _) = mult_0 {n=(n*m)} {m=p}
//    (n_m_to, _) = mult_0 {n} {m}
//    (_, or_a_fro) = or_assoc {p=(n=Z)} {q=(m=Z)} {r=(p=Z)}
//    in or_a_fro $ case nm_p_to prf of
//      Left prf ౬> Left $ n_m_to prf
//      Right prf ౬> Right prf
To_mult_0_3 (n: Nat) (m: Nat) (p: Nat) (e: Equal (Nat.mul n (Nat.mul m p)) Nat.zero) : Either (Equal n Nat.zero) (Either (Equal m Nat.zero) (Equal p Nat.zero))
To_mult_0_3 n m p e = Equivalence.lft (Or_assoc (Equal n Nat.zero) (Equal m Nat.zero) (Equal p Nat.zero))


// fro : ((n = Z) `Either` ((m = Z) `Either` (p = Z))) -> (n * m * p = Z)
// fro (Left Refl) = Refl
// fro {n} (Right (Left Refl)) = rewrite multZeroRightZero n in Refl
// fro {n} {m} (Right (Right Refl)) = rewrite multZeroRightZero (n*m) in Ref
#partial
Fro_mult_0_3 (n: Nat) (m: Nat) (p: Nat) (e: Either (Equal n Nat.zero) (Either (Equal m Nat.zero) (Equal p Nat.zero))) : (Equal (Nat.mul n (Nat.mul m p)) Nat.zero )
Fro_mult_0_3 Nat.zero m         p (Either.left Equal.refl)  = Equal.refl
Fro_mult_0_3 n        Nat.zero  p (Either.right Equal.refl) = Mult_0_r n
Fro_mult_0_3 n        m         Nat.zero (Either.right Equal.refl) = 
  let mult_0_r_m = Mult_0_r m
  let mult_0_r_n = Mult_0_r n
  let rwt = Equal.rewrite (Equal.mirror mult_0_r_m) (x => (Equal Nat (Nat.mul n x) 0n)) mult_0_r_n
  rwt
Fro_mult_0_3 (Nat.succ n) m p (Either.left e) =
  let emp = (Equal.rewrite e 
    (x => match Nat x {
      zero => Empty
      succ => Unit
    })
    (Unit.new))
  Empty.absurd emp
Fro_mult_0_3 n (Nat.succ m) p (e) =
  let mult_0_r_n = Mult_0_r n
  let mult_m_p_eq_0 = Mult_n_m_eq_z m p (Either.rgt (Either.rgt e))
  let rwt = Equal.rewrite (Equal.mirror (mult_m_p_eq_0)) (x => (Equal Nat (Nat.mul n x) 0n))  mult_0_r_n
  rwt
Fro_mult_0_3 n m (Nat.succ p) (Either.right a (Either b c) (Either.right e)) =
  let emp = (Equal.rewrite e
		(x => match Nat x {
		  zero => Empty
			succ => Unit
		}) 
		(Unit.new)) 
	Empty.absurd emp
// Fro_mult_0_3 Nat.zero Nat.zero Nat.zero (Either.right (Either.left e))  = Equal.refl
// Fro_mult_0_3 Nat.zero Nat.zero Nat.zero (Either.right (Either.right e)) = Equal.refl
// Fro_mult_0_3 Nat.zero Nat.zero (Nat.succ p) (Either.right (Either.left e) ) = Equal.refl

// apply_iff_example : (n, m : Nat) -> n * m = Z -> ((n = Z) `Either` (m = Z))
// apply_iff_example n m = fst $ mult_0 {n} {m}
Apply_iff_example (n: Nat) (m: Nat) (e: Equal (Nat.mul n m) Nat.zero) : Either (Equal n Nat.zero) (Equal m Nat.zero)
Apply_iff_example n m e = Equivalence.rgt (Mult_0 n m)

Four_is_even : Sigma Nat (n => (Equal Nat 4n (Nat.add n n)))
Four_is_even = $ 2n Equal.refl


Exists_example_2 (n: Nat) (m: Sigma Nat (m => (Equal Nat n (Nat.add 4n m)))) : Sigma Nat (o => (Equal Nat n (Nat.add 2n o)))
Exists_example_2 n (Sigma.new a b fst snd) = $ (Nat.add 2n fst) (specialize b into #0 in snd)


// In : (x : a) -> (l : List a) -> Type
// In x [] = Void
// In x (x' :: xs) = (x' = x) `Either` In x xs
In <a> (x: a) (xs: List a) : Type
In a x List.nil = Empty
In a x (List.cons xs.h xs.t) = (Either (Equal a x xs.h) (In x xs.t))

// In_example_1 : In 4 [1, 2, 3, 4, 5]
// In_example_1 = Right $ Right $ Right $ Left Ref

In_example_1 : In 4n [1n, 2n, 3n, 4n, 5n]
In_example_1 = (Either.right (Either.right (Either.right (Either.left Equal.refl))))

// In_example_2 : In n [2, 4] -> (n' : Nat ** n = 2 * n')
// In_example_2 (Left Refl) = (1 ** Refl)
// In_example_2 (Right $ Left Refl) = (2 ** Refl)
// In_example_2 (Right $ Right prf) = absurd pr

In_example_2 (n: Nat) (i: In n [2n, 4n])  : Sigma Nat (m => (Equal n (Nat.mul 2n m)))
In_example_2 n (Either.left  e)           = $ 1n e 
In_example_2 n (Either.right e)           = $ 2n (Either.lft e)

// In_map : (f : a -> b) -> (l : List a) -> (x : a) -> In x l -> In (f x) (map f l)
// In_map _ [] _ ixl = absurd ixl
// In_map f (x' :: xs) x (Left prf) = rewrite prf in Left Refl
// In_map f (x' :: xs) x (Right r) = Right $ In_map f xs x r

In_map <a> <b> (f: a -> b) (xs: List a) (x: a) (i: In x xs) : In (f x) (List.map xs f) 
In_map a b f (List.nil) x i = Empty.absurd i
In_map a b f (List.cons xs.h xs.t) x (Either.right e) = Either.right (In_map f xs.t x e)
In_map a b f (List.cons xs.h xs.t) x (Either.left e)  = 
    (Equal.rewrite e 
    (y => (Either (Equal (f x) (f y)) (In (f x) (List.map xs.t f)))) 
    (Either.left Equal.refl))

// In_map_iff : (f : a -> b) -> (l : List a) -> (y : b) -> (In y (map f l)) <-> (x ** (f x = y, In x l))
// In_map_iff f l y = ?In_map_iff_rhs

// In_map_equiv <a> <b> (f: a -> b) (l: List a) (y: b) :
  // Equivalence (In y (List.map l f)) (Sigma a (x => (Pair (Equal (f x) y) (In x l))))
// In_map_equiv a b f List.nil y =
  // (Equivalence.new
    // (x => Empty.absurd x)
    // ((k: (Sigma a (x => (Pair (Equal (f x) y) Empty)))) => (
    // _
    // (?)
  // )))

// App_nil_r <x> (xs: List x) : Equal (List.concat xs List.nil) xs

Either.swap_prf <l> <r> : Equal (Either l r) (Either r l)

// TODO: Terminar depois
#partial
In_app_equiv <a> (x: a) (l1: List a) (l2: List a) :
  (Equivalence (In x (List.concat l1 l2)) (Either (In x l1) (In x l2)))
In_app_equiv a x List.nil l2 =
  let swap_prf          = Either.swap_prf (In x l2) Empty 
  let in_app_equiv      = In_app_equiv a x l2 List.nil
  let app_nil_r_l2      = App_nil_r l2
  let rwt_nil_equiv     = Equal.rewrite app_nil_r_l2 (z => (Equivalence (In x (z)) (Either (In x l2) Empty))) in_app_equiv 
  let rwt_swap_prf_rwt  = Equal.rewrite swap_prf (z => (Equivalence (In a x l2) z)) rwt_nil_equiv 
  rwt_swap_prf_rwt

All <t> (p: t -> Type) (l: List t)  : Type
All t p List.nil                    = Empty 
All t p (List.cons xs.h xs.t)       = Pair (p xs.h) (All t p xs.t)

// #TODO: terminar
All_in <t> (p: t -> Type) (l: List t) : Equivalence ((x: t) -> (i: In x l) -> p x) (All p l)
All_in t p l =  Equivalence.new (x => All_in_rgt t p l x) (x => All_in_lft t p l x)

All_in_rgt <t> (p: t -> Type) (l: List t) (e: (x: t) -> (i: (In x l)) -> (p x)) : (All p l)
All_in_rgt t p List.nil e = Empty.absurd _
All_in_rgt t p (List.cons xs.h xs.t) e =
  let ehd = e xs.h
  let lft = ehd (Either.left Equal.refl)  
  let rgt = All_in_rgt t p xs.t (x => y => e x (Either.right y))
  Pair.new (lft) (rgt)

All_in_lft <t> (p: t -> Type) (l: List t) (e: All p l) : (x : t) -> (i : (In x l)) -> (p x)
All_in_lft t p List.nil  e = Empty.absurd _
All_in_lft t p (List.cons xs.h xs.t) (Pair.new fst snd) = x => y =>
  let ind = All_in_lft t p xs.t snd
  let eit = Either.rgt y
  (ind x eit)

// All_in <t> (x: t) (xs: List t) (e: In x xs) (p: t -> Type) : Equivalence (p x) (All p xs)
// All_in t x List.nil (e) p = Equivalence.new ((y: p x) => e) (Empty.absurd e)
// All_in t x (List.cons xs.h xs.t) (e) p =
  // ?

// combine_odd_even podd peven = \n => if mod n 2 == 1 then podd n else peven n
Combine_odd_even (podd: Nat -> Type) (peven: Nat -> Type) : Nat -> Type
Combine_odd_even podd peven = (n: Nat) => (Bool.if (Nat.is_odd n) (podd n) (peven n))
// #partial
// Combine_odd_even_intro
  // (podd:  Nat -> Type)
  // (peven: Nat -> Type)
  // (n: Nat) ->
  // (p1: (Equal (Nat.is_odd n) Bool.true)  -> podd  n) ->
  // (p2: (Equal (Nat.is_odd n) Bool.false) -> peven n) : (Combine_odd_even (podd) (peven)) n
// Combine_odd_even_intro (Nat.succ (Nat.succ n)) podd peven p1 p2 =
  // let ind = Combine_odd_even_intro n podd peven p1 p2
  // let oddd = p1 (Is_odd n)
  // ?
 

Is_odd (n: Nat) : Equal Bool (Nat.is_odd n) Bool.true

Is_even (n: Nat) : Equal Bool (Nat.is_odd n) Bool.false

Ifunciona <l> <r> (b: Bool.if Bool.true l r ) : l
Ifunciona l r b = b

Combine_odd_even_elim_odd
  (n: Nat)
  (podd:  Nat -> Type)
  (peven: Nat -> Type)
  (p: (Combine_odd_even podd peven) n)
  (e: Equal (Nat.is_odd n) Bool.true) : podd n
// Combine_odd_even_elim_odd n podd peven p e = ?

// combine_odd_even_elim_even : (n : Nat) ->
// combine_odd_even podd peven n ->
// oddb n = False ->
// peven n
// combine_odd_even_elim_even n x prf = ?combine_odd_even_elim_even_rhs
Combine_odd_elim_even
  (n: Nat)
  (podd: Nat -> Type)
  (peven: Nat -> Type)
  (p: (Combine_odd_even podd peven) n)
  (e: Equal (Nat.is_odd n) Bool.false) : peven n
// Combine_odd_elim_even n podd peven p e = ?

Plus_comm3 (m: Nat) (n: Nat) (p: Nat) : Equal (Nat.add n (Nat.add m p)) (Nat.add (Nat.add p m) n)
Plus_comm3 m n p = 
  let a = Equal.rewrite (Plus_comm p m) (x => (Equal (Nat.add n (Nat.add m p)) (Nat.add (x) n))) (Plus_comm3 m n p)
  let b = Equal.rewrite (Plus_comm m p) (x => (Equal Nat (Nat.add n (Nat.add m p)) (Nat.add (x) n))) a
  b

#partial
Plus_comm3a (m: Nat) (n: Nat) (p: Nat) : Equal (Nat.add n (Nat.add m p)) (Nat.add (Nat.add p m) n)
Plus_comm3a Nat.zero n p = 
  let pzr = Add_z_r p
  let com = Plus_comm n p
  let rwt = Equal.rewrite (Equal.mirror pzr) (x =>(Equal _ (Nat.add n p) (Nat.add (x) n))) com
  rwt

Lemma_app_ex 
  (n: Nat) 
  (xs: List Nat) 
  (i: In n (List.map xs (x => Nat.mul x Nat.zero)))   : Equal Nat n 0n
Lemma_app_ex n List.nil i                             = Empty.absurd i
Lemma_app_ex n (List.cons xs.h xs.t) (Either.left i)  = 
  let mult_0_r_xsh = Mult_0_r xs.h
  let rwt = Equal.rewrite (Equal.mirror i) (x => Equal Nat x 0n) mult_0_r_xsh
  rwt
Lemma_app_ex n (List.cons xs.h xs.t) (Either.right i) = Lemma_app_ex n xs.t i

Add_zero (n: Nat)       : (Equal (Nat.add n Nat.zero) n)
Add_zero Nat.zero       = Equal.refl
Add_zero (Nat.succ n)   =
     let ind = Add_zero n
     let app = (Equal.apply (x => (Nat.succ x)) ind)
     app

Function_equality_ex1 : Equal (Nat.succ 3n) (Nat.succ (Nat.pred 4n))
Function_equality_ex1 = Equal.refl

Function_equality_ex2 : Equal ((x: Nat) => Nat.add x 1n) ((x: Nat) => Nat.add 1n x)
Function_equality_ex2 =
  Functional_extensionality ((x: Nat) => Nat.add x 1n) ((x: Nat) => Nat.add 1n x) (x => Plus_comm x 1n)

Functional_extensionality <a><b> (f: a -> b) (g: a -> b) (e: (x: a) -> Equal (f x) (g x)) : Equal f g
// Functional_extensionality a b f g e = Confia e

Plus_1_eq_succ (x: Nat) : Equal (Nat.add x 1n) (Nat.succ x)
Plus_1_eq_succ Nat.zero = Equal.refl
Plus_1_eq_succ (Nat.succ n) = 
  let ind = Plus_1_eq_succ n
  Equal.apply (x => Nat.succ x) ind

Rev_append <x> (l1: List x) (l2: List x)  : List x
Rev_append x List.nil l2                  = l2
Rev_append x (List.cons xs.h xs.t) l2     = Rev_append xs.t (List.cons xs.h l2) 

Tr_rev <x> (l: List x) : List x
Tr_rev x l = Rev_append x l List.nil

Tr_rev_correct <a> (xs: List a)         : Equal (Tr_rev xs) (Rev xs)
Tr_rev_correct a List.nil               = Equal.refl
Tr_rev_correct a (List.cons xs.h xs.t)  =
  let ind  = Tr_rev_correct a xs.t
  let app1 = Equal.apply (x => List.concat x (List.cons xs.h List.nil)) ind
  let eql  = List_equal2 xs.t [xs.h]
  let rwt  = Equal.rewrite (Equal.mirror eql) (x => (Equal (x) (List.concat (Rev xs.t) (List.cons xs.h (List.nil))))) app1
  rwt

List_equal <a> (xs: List a) : Equal (List.concat xs List.nil) xs
List_equal a List.nil               = Equal.refl
List_equal a (List.cons xs.h xs.t)  = 
  let ind = List_equal a xs.t
  let app = Equal.apply (x => List.cons xs.h x) ind
  app

List_equal2 <a> (xs: List a) (ys: List a) : Equal (Rev_append xs ys) (List.concat (Rev_append xs List.nil) ys)
List_equal2 a List.nil ys                 = Equal.refl
List_equal2 a (List.cons xs.h xs.t) ys    =
  let ind1 = List_equal2 a xs.t (List.cons xs.h ys)
  let ind2 = List_equal2 a xs.t [xs.h]
  let app1 = Equal.apply (x => List.concat x ys) ind2
  let ass1 = App_assoc (Rev_append xs.t List.nil) (List.cons xs.h List.nil) ys
  let chn1 = Equal.chain (app1) ass1
  let chn2 = Equal.chain ind1 (Equal.mirror chn1) 
  chn2

Evenb_double (k: Nat)     : Equal (Nat.is_even (Nat.double k)) Bool.true
Evenb_double Nat.zero     = Equal.refl
Evenb_double (Nat.succ k) = Evenb_double k

Evenb_double_conv (n: Nat):
  Sigma Nat (k => (Equal n (Bool.if (Evenb n) (Nat.double k) (Nat.succ (Nat.double k)))))
// Evenb_double_conv Nat.zero                        = $ 0n (Equal.refl)
// Evenb_double_conv (Nat.succ Nat.zero)             = $ 0n (Equal.refl)
// Evenb_double_conv (Nat.succ (Nat.succ n))  =
//   let nnb  = Not_not_eq_b (Evenb n)
//   let ind  = Evenb_double_conv n
//   let test = match Sigma ind {
//     new fst snd =>
//       (
//         // let test1 = Equal.apply (x => Bool.if_not x) snd
//         let test3 = Equal.apply (x => Nat.succ (Nat.succ x)) snd
//         let test4 = Big_ifao n fst
//         let chn   = Equal.chain test3 test4
//         chn
//       )
//     }
//   let test2 = match Sigma ind {
//     new fst snd => (
//       let nnb  = Not_not_eq_b (Evenb n)
//       let rwt  = Equal.rewrite (Equal.mirror nnb) (x => (Equal Nat n (Bool.if _ (x) (Nat.double fst) (Nat.succ (Nat.double fst))))) snd
//       let rwt1 = Equal.rewrite rwt (x => (Sigma Nat (k => (Equal Nat x (Bool.if Nat (Evenb n) (Nat.double k) (Nat.succ (Nat.double k))))))) ind
//       let rwt2 = Equal.rewrite nnb (x => (Sigma Nat (k => (Equal Nat (Bool.if Nat (Bool.not (Bool.not (Evenb n))) (Nat.double fst) (Nat.succ (Nat.double fst))) (Bool.if Nat (Evenb n) (Nat.double k) (Nat.succ (Nat.double k))))))) rwt1
//       rwt2
//     )
//   }
//   let test3 = match Sigma test2 {
//     new fst snd => snd
//   }
//   let test4 = match Sigma test2 {
//     new fst snd => fst
//   }
//   let rwt3  = Equal.rewrite (test3) (x => (Sigma Nat (k => (Equal Nat (x) (_))))) test2
//   let test5 = match Sigma test2 {
//     new fst snd => (Big_ifinho n fst)
//   }
//   let chn = Equal.chain test (test5)
// ?
//


// • Expected: (Sigma Nat (k => (Equal Nat (Nat.succ (Nat.succ n)) (Bool.if Nat (Bool.not (Bool.not (Evenb n)))                   (Nat.double k)                           (Nat.succ (Nat.double k))))))
// =========================================================================================================================================================================================================
// •   nnb   : (Equal Bool                                                      (Bool.not (Bool.not (Evenb n))) (Evenb n))
// =========================================================================================================================================================================================================
// •   ind   : (Sigma Nat (k => (Equal Nat                     n   (Bool.if Nat                     (Evenb n)                     (Nat.double k)                           (Nat.succ (Nat.double k))))))
// =========================================================================================================================================================================================================
// •   test  :                  (Equal Nat (Nat.succ (Nat.succ n)) (Bool.if Nat                     (Evenb n) (Nat.succ (Nat.succ (Nat.double fst)))   (Nat.succ (Nat.succ (Nat.succ (Nat.double fst))))))
// =========================================================================================================================================================================================================
// •   test2 : (Sigma Nat (k => (Equal Nat                         (Bool.if Nat (Bool.not (Bool.not (Evenb n)))                   (Nat.double fst)                         (Nat.succ (Nat.double fst))) 
//                                                                 (Bool.if Nat                     (Evenb n)                     (Nat.double k)                           (Nat.succ (Nat.double k))))))
// =========================================================================================================================================================================================================
// •   test3 : (Equal Nat                                          (Bool.if Nat (Bool.not (Bool.not (Evenb n)))                   (Nat.double fst)                         (Nat.succ (Nat.double fst))) 
//                                                                 (Bool.if Nat                     (Evenb n)                     (Nat.double fst)                         (Nat.succ (Nat.double fst))))
// =========================================================================================================================================================================================================
// •   rwt3  : (Sigma Nat (k => (Equal Nat                         (Bool.if Nat                     (Evenb n)                     (Nat.double fst)                         (Nat.succ (Nat.double fst))) 
//                                                                 (Bool.if Nat                     (Evenb n)                     (Nat.double k)                           (Nat.succ (Nat.double k))))))
// =========================================================================================================================================================================================================
// •   test5 : (Equal Nat                                          (Bool.if Nat                     (Evenb fst) (Nat.succ (Nat.succ (Nat.double fst))) (Nat.succ (Nat.succ (Nat.succ (Nat.double fst))))) 
//                                                                 (Bool.if Nat                     (Evenb fst)                     (Nat.double fst)                       (Nat.succ (Nat.double fst))))
// =========================================================================================================================================================================================================


//
//
// • Expected: (Sigma Nat (k => (Equal Nat (Nat.succ (Nat.succ n)) (Bool.if Nat (Bool.not (Bool.not (Evenb n))) (Nat.double k) (Nat.succ (Nat.double k))))))
//
// •   nnb   :                  (Equal Bool (Bool.not (Bool.not (Evenb n))) (Evenb n))

// •   ind   : (Sigma Nat (k => (Equal Nat                     n   (Bool.if Nat                     (Evenb n) (Nat.double k) (Nat.succ (Nat.double k))))))

// •   test  :                  (Equal Nat (Nat.succ (Nat.succ n)) (Bool.if Nat                     (Evenb n) (Nat.succ (Nat.succ (Nat.double fst))) (Nat.succ (Nat.succ (Nat.succ (Nat.double fst))))))

// •   test2 : (Sigma Nat (k => (Equal Nat                         (Bool.if Nat (Bool.not (Bool.not (Evenb n))) (Nat.double fst) (Nat.succ (Nat.double fst))) 
//                                                                 (Bool.if Nat                     (Evenb n)   (Nat.double k)   (Nat.succ (Nat.double k))))))          ==> rgt feito

// •   test3 : (Equal Nat                                          (Bool.if Nat (Bool.not (Bool.not (Evenb n))) (Nat.double fst) (Nat.succ (Nat.double fst))) 
//                                                                 (Bool.if Nat                     (Evenb n) (Nat.double fst) (Nat.succ (Nat.double fst))))

// •   rwt3  : (Sigma Nat (k => (Equal Nat                         (Bool.if Nat                     (Evenb n) (Nat.double fst) (Nat.succ (Nat.double fst))) 
//                                                                 (Bool.if Nat                     (Evenb n) (Nat.double k)   (Nat.succ (Nat.double k))))))

// •   test5 :                  (Equal Nat                         (Bool.if Nat                     (Evenb n) (Nat.succ (Nat.succ (Nat.double n))) (Nat.succ (Nat.succ (Nat.succ (Nat.double n))))) 
//                                                                 (Bool.if Nat                     (Evenb n)                     (Nat.double n)                       (Nat.succ (Nat.double n))))


Beq_nat_true_equiv (n1: Nat) (n2: Nat) : Equivalence (Equal (Nat.equal n1 n2) Bool.true) (Equal n1 n2)
Beq_nat_true_equiv n1 n2 = Equivalence.new (x => To_beq_nat_true n1 n2 x) (y => Fro_beq_nat_true n1 n2 y)

To_beq_nat_true (n1: Nat) (n2: Nat) (e: Equal (Nat.equal n1 n2) Bool.true) : Equal n1 n2  
To_beq_nat_true Nat.zero Nat.zero Equal.refl = Equal.refl
To_beq_nat_true Nat.zero (Nat.succ n2) e = 
  let emp = (Equal.rewrite e 
    (x => match Bool x {
      true  => Empty
      false => Unit
    })
    (Unit.new))
  Empty.absurd emp
To_beq_nat_true (Nat.succ n1) Nat.zero e = 
  let emp = (Equal.rewrite e 
    (x => match Bool x {
      true  => Empty
      false => Unit
    })
    (Unit.new))
  Empty.absurd emp
To_beq_nat_true (Nat.succ n1) (Nat.succ n2) e = Equal.apply (x => Nat.succ x) (Extract_equal n1 n2 e)

Fro_beq_nat_true (n1: Nat) (n2: Nat) (e: Equal  n1 n2) : Equal (Nat.equal n1 n2) Bool.true
Fro_beq_nat_true Nat.zero Nat.zero Equal.refl = Equal.refl
Fro_beq_nat_true Nat.zero (Nat.succ n2) e = 
  let emp = (Equal.rewrite e 
    (x => match Nat x {
      zero => Unit
      succ => Empty
    })
    (Unit.new))
  Empty.absurd emp
Fro_beq_nat_true (Nat.succ n1) Nat.zero e = 
  let emp = (Equal.rewrite e 
    (x => match Nat x {
      zero => Empty
      succ => Unit
    })
    (Unit.new))
  Empty.absurd emp
Fro_beq_nat_true (Nat.succ n1) (Nat.succ n2) e =
  let e2 = Succ_n1_n2 n1 n2 e
  let ind = Fro_beq_nat_true n1 n2 e2
  ind

// is_even_prime : Nat -> Bool
// is_even_prime n = if n = 2 then True else False
Is_even_prime : Nat -> Bool
Is_even_prime = (n: Nat) => Bool.if (Nat.equal n 2n) Bool.true Bool.false

// even_1000 : (k ** 1000 = double k)
Even_1000 : Sigma Nat (k => Equal 1000n (Nat.double k))
Even_1000 = $ 500n Equal.refl

// even_1000' : evenb 1000 = True
// even_1000' = Refl
Even_1000a : Equal (Evenb 1000n) Bool.true
Even_1000a = Equal.refl

// even_1000'' : (k ** 1000 = double k)
// even_1000'' = (fst $ even_bool_prop {n=1000}) Refl
// Even_1000b : Sigma Nat (k => Equal 1000n (Nat.double k))
// Even_1000b =
  // let test5 = match {
    // new fst snd => fst
  // }
  // ?

Extract_lambda <p> <q> (f: p -> q) : p
Extract_lambda p q f = (Invert_lambda f) (Apply_lambda f (Extract_lambda f))

Apply_lambda <p> <q> (f: p -> q) (x: p) : q
Apply_lambda p q f x = f (Extract_lambda f) 

Invert_lambda <p> <q> (f: p -> q) : q -> p
Invert_lambda p q f = (x: q) => (Extract_lambda f) 

#axiom
Either.rgt <l> <r> (e: Either l r) : r

#axiom
Either.lft <l> <r> (e: Either l r) : l

Not_true_false    :  Not(Equal Bool Bool.true Bool.false)
Not_true_false    = x => (Equal.rewrite x (k => if k { Nat } else { Empty }) Nat.zero)

Zero_nbeq_plus_1  (n: Nat)      : (Equal Bool (Nat.equal Nat.zero (Nat.add n (Nat.succ Nat.zero))) Bool.false)
Zero_nbeq_plus_1  Nat.zero      = Equal.refl
Zero_nbeq_plus_1  (Nat.succ n)  = Equal.refl

Contradiction_implies_anythig <p> <q> (a: Pair p (Not p)) : q
Contradiction_implies_anythig p q (Pair.new fst snd) =
  let app = snd fst
  Empty.absurd app

Not_true_is_false (b: Bool) (h: Not (Equal Bool b Bool.true)) : (Equal Bool b Bool.false)
Not_true_is_false Bool.false h = Equal.refl
Not_true_is_false Bool.true  h = Empty.absurd (h Equal.refl)

Not_implies_our_not1 <p> (e: Not p) : p -> Empty
Not_implies_our_not1 p e = e

Not_implies_our_not <p> (e: p) : Empty
Not_implies_our_not p e =  
  let test  = (x: Not p) => Not_implies_our_not1 p (x)  
  let test1 = Not_implies_our_not test
  test1

Confia <x> (e : x -> Type) : Type

Evenb (n: Nat)              : Bool
Evenb Nat.zero              = Bool.true
Evenb (Nat.succ k)          = Bool.not (Evenb k)

#partial
Problems.t23 (n: Nat) (m: Nat) (e: Equal (Nat.equal n m) Bool.true): (Equal n m)
Problems.t23 Nat.zero Nat.zero e            = Equal.refl 
Problems.t23 (Nat.succ n) (Nat.succ m) e    =
    let ind  = Problems.t23 n m e     
    let app  = Equal.apply (x => (Nat.succ x)) ind 
    app 


// #############################################################################################
// #################################### COMEÇA AQUI#############################################
// #############################################################################################
Andb_true_equiv 
  (b1: Bool) 
  (b2: Bool) : Equivalence (Equal (Bool.and b1 b2) Bool.true) (Pair (Equal b1 Bool.true) (Equal b2 Bool.true))
Andb_true_equiv b1 b2 = Equivalence.new (x => Fro_andb_true_equiv b1 b2 x) (y => To_andb_true_equiv b1 b2 y)

To_andb_true_equiv 
  (b1: Bool) 
  (b2: Bool) 
  (e: (Pair (Equal b1 Bool.true) (Equal b2 Bool.true))) : (Equal (Bool.and b1 b2) Bool.true) 
To_andb_true_equiv Bool.true  b2 e = Pair.snd e
To_andb_true_equiv Bool.false b2 e = Pair.fst e

Fro_andb_true_equiv 
  (b1: Bool) 
  (b2: Bool) 
  (e: (Equal (Bool.and b1 b2) Bool.true)) : (Pair (Equal b1 Bool.true) (Equal b2 Bool.true))
Fro_andb_true_equiv Bool.true  b2 e = Pair.new Equal.refl e
Fro_andb_true_equiv Bool.false Bool.true e = 
  let nff   = Equal.apply (x => Bool.not x) e
  Pair.new e (Equal.chain nff e)
Fro_andb_true_equiv Bool.false Bool.false e = Pair.new e e

Orb_true_equiv 
  (b1: Bool) 
  (b2: Bool): Equivalence (Equal (Bool.or b1 b2) Bool.true) (Either (Equal b1 Bool.true) (Equal b2 Bool.true))
Orb_true_equiv b1 b2 = Equivalence.new (x => To_orb_true_equiv b1 b2 x) (y => Fro_orb_true_equiv b1 b2 y)

Fro_orb_true_equiv 
  (b1: Bool) 
  (b2: Bool) 
  (e: Either (Equal b1 Bool.true) (Equal b2 Bool.true)) : Equal (Bool.or b1 b2) Bool.true
Fro_orb_true_equiv Bool.true b2 e  = Either.lft e
Fro_orb_true_equiv Bool.false b2 e = Either.rgt e

To_orb_true_equiv 
  (b1: Bool) 
  (b2: Bool) 
  (e: Equal (Bool.or b1 b2) Bool.true) : Either (Equal b1 Bool.true) (Equal b2 Bool.true)
To_orb_true_equiv Bool.true b2 e  = Either.left  (Equal Bool.true Bool.true) (Equal b2 Bool.true) e
To_orb_true_equiv Bool.false b2 e = Either.right (Equal Bool.false Bool.true)(Equal b2 Bool.true) e

Fro_orb_true_equiv1 
  (b1: Bool) 
  (b2: Bool) 
  (e: Equal b1 b2) : Equal (Bool.or b1 b2) Bool.true
Fro_orb_true_equiv1 Bool.true b2          e = Equal.refl
Fro_orb_true_equiv1 Bool.false Bool.true  e = Equal.refl
Fro_orb_true_equiv1 Bool.false Bool.false e = 
  let nff  = Equal.apply (x => Bool.not x) e
  let test2 = (x: (Equal Bool.true Bool.true )) => (Not_implies_our_not x) 
  let test = Not_true_is_false Bool.true test2
  Equal.mirror test

Beq_nat_false_equiv (n1: Nat) (n2: Nat) : Equivalence (Equal (Nat.equal n1 n2) Bool.false) (Not (Equal n1 n2))
Beq_nat_false_equiv n1 n2 = Equivalence.new  (x => To_beq_nat_false n1 n2 x) (y => Fro_beq_nat_false n1 n2 y)

Fro_beq_nat_false (n1: Nat) (n2: Nat) (e : Not (Equal n1 n2)) : (Equal (Nat.equal n1 n2) Bool.false)
Fro_beq_nat_false Nat.zero Nat.zero e =  
  Not_true_is_false Bool.true ((x: Equal Bool.true Bool.true) => (e Equal.refl))
Fro_beq_nat_false Nat.zero (Nat.succ n2) e = Equal.refl
Fro_beq_nat_false (Nat.succ n1) Nat.zero e = Equal.refl
Fro_beq_nat_false (Nat.succ n1) (Nat.succ n2) e =
  let test = (x: Equal (Nat.equal n1 n2) Bool.true) => Problems.t23 n1 n2 x
  let test1 = Extract_lambda test
  let test2 = Not_true_is_false Bool.true ((x: Equal Bool.true Bool.true) => (e (Extract_lambda e)))
  Equal.chain test1 test2
  // ?

To_beq_nat_false (n1: Nat) (n2: Nat) (e : (Equal (Nat.equal n1 n2) Bool.false)) : Not (Equal n1 n2)
To_beq_nat_false Nat.zero Nat.zero e           = (x: Equal  Nat.zero      Nat.zero)     => Not_implies_our_not x
To_beq_nat_false Nat.zero (Nat.succ n2) e      = (x: Equal  Nat.zero     (Nat.succ n2)) => Not_implies_our_not x
To_beq_nat_false (Nat.succ n1) Nat.zero e      = (x: Equal (Nat.succ n1)  Nat.zero)     => Not_implies_our_not x
To_beq_nat_false (Nat.succ n1) (Nat.succ n2) e = (x: Equal (Nat.succ n1) (Nat.succ n2)) => Not_implies_our_not x

// beq_list : (beq : a -> a -> Bool) -> (l1, l2 : List a) -> Bool
// beq_list beq l1 l2 = ?beq_list_rhs
Beq_list <a> (beq: a -> a -> Bool) (xs: List a) (ys: List a) : Bool
Beq_list a beq List.nil List.nil = Bool.true
Beq_list a beq List.nil (List.cons ys.h ys.t) = Bool.false
Beq_list a beq (List.cons xs.h xs.t) List.nil = Bool.false
Beq_list a beq (List.cons xs.h xs.t) (List.cons ys.h ys.t) = Beq_list a (xs.h => ys.h => beq xs.h ys.h) xs.t ys.t 

// beq_list_true_iff : (beq : a -> a -> Bool) ->
// ((a1, a2 : a) -> (beq a1 a2 = True) <-> (a1 = a2)) ->
// ((l1, l2 : List a) -> (beq_list beq l1 l2 = True) <-> (l1 = l2))
// beq_list_true_iff beq f l1 l2 = ?beq_list_true_iff_rhs
Beq_list_true_equiv <a> 
  (beq: a -> a -> Bool) 
  (a1: a) 
  (a2: a) 
  (e: Equivalence (Equal (beq a1 a2) Bool.true) (Equal a1 a2))
  (xs: List a)
  (ys: List a): Equivalence (Equal (Beq_list beq xs ys) Bool.true) (Equal xs ys)
Beq_list_true_equiv a beq a1 a2 e xs ys =
  Equivalence.new  (x => Fro_beq_list_true a beq xs ys x)  ((y: Equal xs ys ) => To_beq_list_true beq xs ys)

#partial
To_beq_list_true <a> 
  (beq: a -> a -> Bool) 
  (xs: List a) 
  (ys: List a) : Equal (Beq_list beq xs ys) Bool.true
To_beq_list_true a beq List.nil List.nil = Equal.refl
To_beq_list_true a beq List.nil (List.cons ys.h ys.t) = 
  Equal.mirror (Not_true_is_false Bool.true ((x: Equal Bool.true Bool.true) => Not_implies_our_not x))
To_beq_list_true a beq (List.cons xs.h xs.t) List.nil = 
  Equal.mirror (Not_true_is_false Bool.true ((x: Equal Bool.true Bool.true) => Not_implies_our_not x))
To_beq_list_true a beq (List.cons xs.h xs.t) (List.cons ys.h ys.t) = 
  To_beq_list_true (xs.h => ys.h => beq xs.h ys.h) xs.t ys.t
#partial
Fro_beq_list_true <a> 
  (beq: a -> a -> Bool) 
  (xs: List a) 
  (ys: List a) 
  (e : (Equal (Beq_list beq xs ys) Bool.true)) : (Equal xs ys)
Fro_beq_list_true a beq List.nil List.nil e = Equal.refl
// Fro_beq_list_true a beq List.nil (List.cons ys.h ys.t) e =
  // ?

// forallb : (test : x -> Bool) -> (l : List x) -> Bool
// forallb _ [] = True
// forallb test (x :: xs) = test x && forallb test xs
Forallb <x> (t: x -> Bool) (xs: List x) : Bool
Forallb x t List.nil = Bool.true
Forallb x t (List.cons xs.h xs.t) = Bool.and (t xs.h) (Forallb t xs.t)

// All <x> (t: x -> Bool) (xs: List x) : Bool
// All x t List.nil = Bool.true
// All x t (List.cons xs.h xs.t) = Bool.if (t xs.h) (All t xs.t) Bool.false

All <t> (p: t -> Type) (l: List t)  : Type
All t p List.nil                    = Empty 
All t p (List.cons xs.h xs.t)       = Pair (p xs.h) (All t p xs.t)

// forallb_true_iff : (l : List x) -> (forallb test l = True) <-> (All (\x => test x = True) l)
// forallb_true_iff l = ?forallb_true_iff_rhs
Forallb_true_equiv <x> 
  (t: x -> Bool) 
  (xs: List x) : 
  Equivalence (Equal (Forallb t xs) Bool.true) ((All ((k: x) => Equal (t k) Bool.true) xs))
// Forallb_true_equiv x t xs = ?


To_forall <x> (t: x -> Bool) (xs: List x) (e: Equal (Forallb t xs) Bool.true) : (All (k => (Equal (t k) Bool.true)) xs)
To_forall x t List.nil e              = Not_implies_our_not e
To_forall x t (List.cons xs.h xs.t) e = 
  let a = Forallb t [xs.h] 
  ?





Main {

  // let c = Filter_even_gt7 b
  let d = [1n, 2n, 3n, 4n]
  let e = Maybe.some (3n)
  // Maybe_map (x => Nat.add 2n x) e
  // let f = Fold (x => y => (+ y x))  b 1
  // f
  // One
  // One
  // Two
  // Three
  // Three
  // Plus_fact
  // Exp Two Three
  // Is_three 2n
  // Fold (x => y => (Bool.and y x)) [Bool.true, Bool.false, Bool.true] Bool.true
  // List.nat_show (Fold (x => y => (List.concat x y)) [[1n], [], [2n, 3n], [], [4n]] [5n, 6n, 7n, 8n])
  // List.nat_show d
  // (x => Nat.show x) c

  // Nat.show (Plus3 3n)
  // let pmap = f => (x: Pair Nat Nat ) => Pair.new (Pair.map_fst (Pair.fst x) f ) (Pair.map_snd (Pair.snd x) f)
  // Pair_curry (x => (y) => (Pair.new y y))  1n 2n
 // Nat.show (Inc 0n)
 Tr_rev d
 // Black_friday2 (3n) Equal.refl
 // Evenb_double_conv 1n
 // (Pair.map (Prova2 3n 7n)(x => Nat.to_u60 x))
 }

#partial
Bool.if_not <a> (i: a) : a
Bool.if_not (Bool.if a b t f ) = (Bool.if a (Bool.not b) t f)

Big_ifao (n: Nat) (k: Nat):
  (Equal (Nat.succ (Nat.succ (Bool.if (Evenb n) (Nat.double k) (Nat.succ (Nat.double k))))) 
  (Bool.if (Evenb n) (Nat.succ (Nat.succ (Nat.double k))) (Nat.succ (Nat.succ (Nat.succ (Nat.double k))))))
Big_ifao Nat.zero k                 = Equal.refl
Big_ifao (Nat.succ Nat.zero) k      = Equal.refl
Big_ifao (Nat.succ (Nat.succ n)) k  =
  let ind = Big_ifao n k
  let nnb = Not_not_eq_b (Evenb n)
  let rwt = Equal.rewrite (Equal.mirror nnb) (x =>  Equal (Nat.succ (Nat.succ (Bool.if (x) _ _))) (Bool.if (x) _ _))  (ind)
  rwt





Big_ifinho (n: Nat) (fst: Nat) : (Equal Nat  (Bool.if _ (Evenb n) (Nat.succ (Nat.succ (Nat.double fst))) (Nat.succ (Nat.succ (Nat.succ (Nat.double fst)))))   (Bool.if Nat (Evenb n) (Nat.double fst) (Nat.succ (Nat.double fst))))
// Pair.map <a> <b> <c> (pair: Pair a a) (func: a -> c) : Pair c c
// Pair.map a b c (Pair.new t.a t.b p.fst p.snd) func =
  // Pair.new c t.b (func p.fst) (func p.snd)pkkkkkj



Succ_n1_n2 (n1: Nat) (n2: Nat) (e : (Equal Nat (Nat.succ n1) (Nat.succ n2))) : Equal Nat n1 n2
Succ_n1_n2 Nat.zero Nat.zero e            = Equal.refl
Succ_n1_n2 (Nat.succ n1) Nat.zero e       = Equal.apply (x => Nat.pred x) e
Succ_n1_n2 Nat.zero (Nat.succ n2) e       = Equal.apply (x => Nat.pred x) e
Succ_n1_n2 (Nat.succ n1) (Nat.succ n2) e  = Equal.apply (x => Nat.pred x) e

Extract_equal (n1: Nat) (n2: Nat) (e: Equal (Nat.equal n1 n2) Bool.true) : Equal n1 n2
Extract_equal Nat.zero Nat.zero (Equal.refl) = Equal.refl
Extract_equal Nat.zero (Nat.succ n2) (e) = 
  let emp = (Equal.rewrite e 
    (x => match Bool x {
      true  => Empty
      false => Unit
    })
    (Unit.new))
  Empty.absurd emp
Extract_equal (Nat.succ n1) Nat.zero (e) = 
  let emp = (Equal.rewrite e 
    (x => match Bool x {
      true  => Empty
      false => Unit
    })
    (Unit.new))
  Empty.absurd emp
Extract_equal (Nat.succ n1) (Nat.succ n2) e = Equal.apply (x => Nat.succ x) (Extract_equal n1 n2 e)



